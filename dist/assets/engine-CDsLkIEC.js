import{j as w,A as y,by as p}from"./index-9CqTvKgY.js";import{readContract as h}from"./read-contract-BMdzUrUG.js";async function f({account:t,serializableTransaction:e,transaction:n,gasless:r}){const a=y({address:r.relayerForwarderAddress,chain:n.chain,client:n.client}),s=await h({contract:a,method:"function getNonce(address) view returns (uint256)",params:[t.address]}),[o,i]=await(async()=>{if(!e.to)throw new Error("engine transactions must have a 'to' address");if(!e.gas)throw new Error("engine transactions must have a 'gas' value");if(!e.data)throw new Error("engine transactions must have a 'data' value");if(r.experimentalChainlessSupport){const d={chainid:BigInt(n.chain.id),data:e.data,from:t.address,gas:e.gas,nonce:s,to:e.to,value:0n};return[await t.signTypedData({domain:{name:"GSNv2 Forwarder",verifyingContract:a.address,version:"0.0.1"},message:d,primaryType:"ForwardRequest",types:{ForwardRequest:l}}),d]}const c={data:e.data,from:t.address,gas:e.gas,nonce:s,to:e.to,value:0n};return[await t.signTypedData({domain:{chainId:n.chain.id,name:r.domainName??"GSNv2 Forwarder",verifyingContract:a.address,version:r.domainVersion??"0.0.1"},message:c,primaryType:"ForwardRequest",types:{ForwardRequest:g}}),c]})();return{message:i,messageType:"forward",signature:o}}const g=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],l=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function q(t){const{message:e,messageType:n,signature:r}=await f(t),a=await fetch(t.gasless.relayerUrl,{body:w({forwarderAddress:t.gasless.relayerForwarderAddress,request:e,signature:r,type:n}),headers:{"Content-Type":"application/json"},method:"POST"});if(!a.ok)throw new Error(`Failed to send transaction: ${await a.text()}`);const s=await a.json();if(!s.result)throw new Error(`Relay transaction failed: ${s.message}`);const o=s.result.queueId,i=6e4,u=1e3,c=Date.now()+i;for(;Date.now()<c;){const d=await v({options:t,queueId:o});if(d)return{chain:t.transaction.chain,client:t.transaction.client,transactionHash:d.transactionHash};await new Promise(m=>setTimeout(m,u))}throw new Error(`Failed to find relayed transaction after ${i}ms`)}async function v(t){const{options:e,queueId:n}=t,r=e.gasless.relayerUrl.split("/relayer/")[0],a=await fetch(`${r}/transaction/status/${n}`,{method:"GET"}),s=await a.json();if(!a.ok)return null;const o=s.result;if(!o)return null;switch(o.status){case"errored":throw new Error(`Transaction errored with reason: ${o.errorMessage}`);case"cancelled":throw new Error("Transaction execution cancelled.");case"mined":return await p({chain:e.transaction.chain,client:e.transaction.client,transactionHash:o.transactionHash});default:return null}}export{f as prepareEngineTransaction,q as relayEngineTransaction};
