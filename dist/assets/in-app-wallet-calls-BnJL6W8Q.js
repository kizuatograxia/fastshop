import{m,n as h,by as p,bz as w,be as f,bA as T,r as b}from"./index-9CqTvKgY.js";import{s as g}from"./send-transaction-CZeiQyRl.js";async function y(e){const{account:t,transactions:c}=e;if(!t)throw new Error("not connected");if(c.length===0)throw new Error("No transactions to send");const a=c[0];if(!a)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(c.map(async s=>{const[r,l,o,d]=await Promise.all([m(s),h(s.to),h(s.accessList),h(s.value)]);return{accessList:o,chainId:s.chain.id,data:r,to:l,value:d}}));return{...await t.sendBatchTransaction(n),chain:a.chain,client:a.client}}throw new Error("Account doesn't implement sendBatchTransaction")}async function H(e){const t=await g(e);return p(t)}const u=new w(1e3);async function C(e){const{account:t,calls:c}=e,a=c.map(s=>({...s,chain:e.chain})),n=[],i=b(65);if(u.set(i,n),t.sendBatchTransaction){const s=await y({account:t,transactions:a});n.push(s.transactionHash),u.set(i,n)}else for(const s of a){const r=await H({account:t,transaction:s});n.push(r.transactionHash),u.set(i,n)}return i}async function E(e){const{chain:t,client:c,id:a}=e,n=u.get(a);if(!n)throw new Error("Failed to get calls status, unknown bundle id");const i=f({chain:t,client:c});let s="success";const r=await Promise.all(n.map(l=>T(i,{hash:l}).then(o=>({blockHash:o.blockHash,blockNumber:o.blockNumber,gasUsed:o.gasUsed,logs:o.logs.map(d=>({address:d.address,data:d.data,topics:d.topics})),status:o.status,transactionHash:o.transactionHash})).catch(()=>(s="pending",null))));return{atomic:!1,chainId:t.id,id:a,receipts:r.filter(l=>l!==null),status:s,statusCode:200,version:"2.0.0"}}export{E as inAppWalletGetCallsStatus,C as inAppWalletSendCalls};
